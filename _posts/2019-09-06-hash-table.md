---
title: 6.4 hash table
date: 2019-09-11
---

## 1. 散列表的基本概念

在前面介绍的线性表和树表的查找中，记录在表中的位置与记录的关键字之间不存在确定关系，因此，在这些表中查找记录时需进行一系列的关键字比较。这类查找方法建立在 “比较” 的基础上，查找的效率取决于比较的次数。

散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 `Hash(key) = Addr` （这里的地址可以是数组下标、索引或内存地址等）。

散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些发生碰撞的不同关键字称为同义词。一方面，设计得好的散列函数应尽量减少这样的冲突；另一反面，由于这样的冲突总是不可避免的，所以还要涉及好处理冲突的方法。

散列表：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。

理想情况下，对散列表进行查找的时间复杂度为 O(1) ，即与表中元素的个数无关。下面介绍常用的散列函数和处理冲突的方法

## 2. 散列函数的构造方法

在构造散列函数时，必须注意以下几点：

1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。
2. 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生
3. 散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址。

下面介绍常用的散列函数

### 2.1 直接定址法

直接取关键字的某个线性函数值为散列地址，散列函数为

`H(key)=a×key+b`

式中，a 和 b 是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。

### 2.2 除留余数法

这是一种最简单、最常用的方法，假定散列表表长为 m，取一个不大于 m 但最接近或等于 m 的质数 p，利用以下公式把关键字转换成散列地址。散列函数为

```c++
H(key)=key%p
```

除留余数法的关键是选好 p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而仅可能减少冲突的可能性。

### 2.3 数字分析法

设关键字是 r 进制数（如十进制数），而 r 个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。

### 2.4 平方取中法

顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或小于散列地址所需的位数。

### 2.5 折叠法

将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中的每位上数字分布大致均匀时，可以采用折叠法得到散列地址。

在不同的情况下，不同的散列函数会发挥不同的性能，因此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况，但目标是为了尽量降低产生冲突的可能性。

## 3. 处理冲突的方法

应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲突时应该如何处理，即为产生冲突的关键字寻找下一个 “空” 的 Hash 地址。

假设已经选定散列函数 `H(key)` ，下面用 `Hi` 来表示发生冲突后第 i 次探测的散列地址。

### 3.1 开放定址法

所谓开放定址法，是指可存放新表项的空闲地址即向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为

```c++
Hi=(H(key)+di)%m
```

式中，i=0,1,2,...,k(k≤m-1)；m 表示散列表表长；di 为增量序列

取定某一增量序列后，对应的处理方法就是确定的。通常有以下 4 种取法：

1. 线性探测法。当 di=0,1,2,...,m-1 时，称为线性探测法。这种方法的特点是：冲突发生时，顺序查看表中下一个单元（探测到表尾地址 m-1 时，下一个探测地址是表首地址 0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。

   线性探测法可能使第 i 个散列地址的同义词存入第 i+1 个散列地址，这样本应存入第 i+1 个散列地址的元素就争夺第 i+2 个散列地址的元素的地址，从而造成大量元素在相邻的散列地址上 “聚集” （或堆积）起来，大大降低了查找效率。

2. 平方探测法。当 di=0^2,1^2,-1^2,2^2,...,k^2,-k^2 时，称为平方探测法，其中 k ≤ m/2 ，散列表长度 m 必须是一个可以表示成 4k+3 的素数，又称二次探测法。

   平方探测法是一种较好的处理冲突的方法，可以避免出现 “堆积” 问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。

3. 再散列法。当 di=Hash2(key) 时，称为再散列法，又称双散列法。需要使用两个散列函数，当通过第一个散列函数 H(key) 得到的地址发生冲突时，则利用第二个散列函数 Hash2(key) 计算该关键字的地址增量。它的具体散列函数形式如下

   ```c++
   Hi=(H(key)+i×Hash2(key))%m
   ```

   初始探测位置 H0 = H(key)%m 。i 是冲突的次数，初始为 0。再散列法中，最多经过 m-1 次探测就会遍历表中所有位置，回到 H0 位置。

4. 伪随机序列法。当 di = 伪随机数序列时，称为伪随机序列法。

注意：在开放定址的情形下，不能随便物理删除表中的已有元素，因为若删除元素，则会截断其他具有相同散列地址的元素的查找地址。因此，要删除一个元素时，可给它做一个删除标记，进行逻辑删除。但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有很多位置未利用，因此需要定期维护散列表，要把删除标记的元素物理删除（通过移位等方式）。

### 3.2 拉链法（链接法，chaining）

显然，对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为 i 的同义词链表的头指针存储在散列表的第 i 个单元中，因而查找、插入和删除操作主要在同义词链中进行。拉链法适用于经常进行插入和删除的情况。

## 4. 散列查找及性能分析

散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字 key ，根据散列函数可以计算出其散列地址，执行步骤如下：

初始化：Addr=Hash(key);

1. 检测查找表中地址为 Addr 的位置上是否有记录，若无记录，返回查找失败；若有记录，比较它与 key 的值；若相等，则返回查找成功标志，否则执行步骤 2 。
2. 用给定的处理冲突方法计算 “下一个散列地址”，并把 Addr 置为此地址，转入步骤 1 。

散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。

装填因子。散列表的装填因子一般记为 α，定义为一个表的装满程度，即

```c++
α = 表中记录数 n/散列表长度 m
```

散列表的平均查找长度依赖于散列表的填装因子 α，而不直接依赖于 n 或 m。直观地看，α 越大，表示填装的记录越 “满” ，发生冲突的可能性越大，反之发生冲突的可能性越小。

虽然散列表在关键字与记录的存储位置之间建立了直接映射，但由于 “冲突的产生”，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需要以平均查找长度作为衡量散列表的查找效率的度量。读者应能在给出散列表的长度、元素个数及散列函数和解决冲突的方法后，在求出散列表的基础上计算出查找成功时的平均查找长度和查找不成功的平均查找长度。