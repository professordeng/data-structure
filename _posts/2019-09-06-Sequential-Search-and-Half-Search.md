---
title: 6.2 Sequential Search and Half Search
---

## 1. 顺序查找

顺序查找又称线性查找，主要用于在线性表中进行查找。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的顺序表的顺序查找。

### 1.1 一般线性表的顺序查找

从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但没有查找到符合条件的元素，则返回查找失败的信息。

伪代码如下，主要说明其中引入的 “哨兵” 的作用。

```c++
struct SSTable {  // 查找表的数据结构 
	int *elem;    // 元素存储空间基址，建表时按实际长度分配，0 号单位留空
	int TableLen; // 表的长度 
};

int Search_Seq(SSTable ST, int key) {
	// 在顺序表 ST 中顺序查找关键字为 key 的元素。 
	ST.elem[0] = key;   // "哨兵" 
	for(int i = ST.TableLen; ST.elem[i] != key; --i);  
	return i;  // 若表中不存在关键字为 key 的元素，将查找到 i 为 0 时退出 for 循环 
} 
```

在上述算法中，将 `ST.elem[0]` 称为 “哨兵”。引入它的目的是使得 `Search_Seq` 内的循环不必判断数组是否会越界，因为满足 `i==0` 时，循环一定会跳出。需要说明的是，在程序中引入 “哨兵” 并不是这个算法独有的，引入 “哨兵” 可以避免很多不必要的判断语句，从而提高程序效率。

对于有 n 歌元素的表，给定值 key 与表中第 i 个元素的关键字相等，即定位第 i 个元素时，需进行 n-i+1 次关键字的比较，即 `Ci=n-i+1` 。查找成功时，顺序查找的平均长度为

`ASL成功=ΣPi(n-i+1)`

当每个元素的查找概率相等，即 `Pi=1/n` 时，有

`ASL成功=ΣPi(n-i+1)=(n+1)/2`

查找不成功时，与表中各关键字的比较次数显然是 n+1 次，从而顺序查找不成功的平均查找长度为 

`ASL不成功=n+1`

通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由小至大排列。

综上所述，顺序查找的缺点是当 n 较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按关键码有序，均可应用。同时还需注意，对线性的链表只能进行顺序查找。

### 1.2 有序表的顺序查找

## 2. 折半查找

## 3. 方块查找

块内无序，块间有序。