---
title: 5.4 the use of graph
---

本节是历年考查的重点 。图的应用主要包括 ：最小生成（代价）树 、最短路径 、拓扑排序和关键路径 。一般而言 ，这部分内容直接以算法设计题考察的可能性很小，而更多的是结合图的实例来考查算法的具体执行过程，读者必须学会手工模拟给定图的各个算法的执行过程，此外，还需要掌握对给定模型建立相应的图去解决问题的方法 。

## 1. 最小生成树

一个连通图的生成树是图的极小连通图，它包含图中的所有顶点，并且只含尽可能少的边。这意味着对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。

对于一个带权连通无向图 G=(V,E) ，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设 R 是 G 的所有生成树的集合，若 T 为 R 中边的权值之和最小的那棵生成树，则 T 称为 G 的最小生成树（Minimum Spanning Tree，MST）。

不难看出，最小生成树具有如下性质：

1. 最小生成树不是唯一的，即最小生成树的树形不唯一，R 中可能有多个最小生成树 。当图 G 中的各边权值互不相等时，G 的最小生成树是唯一的；若无向连通图 G 的边数比顶点数少 1，即 G 本身就是一棵树时，则 G 的最小生成树就是它本身 。
2. 最小生成树的边的权值之和总是唯一的，虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。
3. 最小生成树的边数为顶点数减-1 。

构造最小生成树有很多算法，但大多数算法都利用了最小生成树的下列性质 ：假设 G=(V,E) 是一个带权连通无向图， U 是顶点集 V 的一个非空子集 。若 (u,v) 是一条具有最小权值的边，其中 u ∈U，v ∈V-U ，则必存在一棵包含边 (u,v) 的最小生成树 。

基于该性质的最小生成树算法主要有 Prim 算法和 Kruskal 算法，它们都基于贪心算法的策略。对这两种算法的掌握不应拘泥于其代码实现，而应掌握算法的本质含义和基本思想，并能够手工模拟算法的具体步骤 。

下面介绍一个通用的最小生成树算法

```c++
GENERIC_MST(G) {
    T=NULL;;
    while T 未形成一棵生成树
        do 找到一条最小代价边 (u,v) 并且加入 T 后不会产生回路
            T=T∪(u,v)
}
```

通用的算法采用每次加入一条边来逐渐形成一棵生成树 。下面介绍两种实现上述通用算法的途径 。

### 1.1 Prim 算法

假设 N={V,E} 是连通网，ET 是 N 上最小生成树中边的集合。算法从 VT={u0} （u0∈V），ET={} 开始，重复执行下述操作：在所有 u ∈ VT，v∈V-VT 的边（u,v）∈E 中找一条代价最小的边（u0,v0）并入集合 ET，同时将 v0 并入 VT，直到 VT=V 为止。此时 ET 中必有 n-1 条边，则 T={VT,ET} 为 N 的最小生成树。

伪代码如下：

```c++
void Prim(G,T) {
	T = emptyset;                 // 初始化空树
    U = {w};                      // 添加任一顶点 w
    while((V-U) != emptyset) {    // 若树中不含全部顶点
        设 (u,v) 是使 u∈U 与 v∈(V-U)，且权值最小的边;
        T = T ∪ {(u,v)};         // 边并入树
        U = U ∪ {v};             // 顶点归入树
    }
}
```

Prim 算法的时间复杂度为 `O(|V|^2)` （每次找点到点的最短距离），不依赖于 `|E|` ，因此它适用于求解边稠密的图的最小生成树。虽然采用其他方法能改进 Prim 算法的时间复杂度，但增加了实现的复杂性。

### 1.2 Kruskal 算法

假设 N=(V,E) 是连通网，对应的最小生成树 T=(VT,ET) ，Kruskal 算法步骤如下

初始化：VT=V，ET = emptyset 。即每个顶点构成一棵独立的树，T 此时是一个仅含 `|V|` 个顶点的森林。

循环（重复下列操作至 T 是一棵树）：按 G 的边的权值递增顺序依次从 E-ET 中选择一条边，若这条边加入 T 后不构成回路，则将其加入 ET ，否则舍弃，直到 ET 中含有 n-1 条边 。

伪代码如下

```c++
void Kruskal(V,T) {
    T = V;      // 初始化树 T，仅含顶点
    numS = n;   // 连通分量数
    while(numS > 1) {  // 若连通分量数大于 1
        从 E 中取出权值最小的边 (v,u);
        if(v 和 u 属于 T 中不同的连通分量) {
            T=T∪{(v,u)};  // 将此边加入生成树中
            numS--;
        }
    }
}
```

根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。

通常在 Kruskal 算法中，采用堆来存放边的集合，因此每次选择最小权值的边只需 `O(log|E|)` 的时间。此外，由于生成树 T 中的所有边可视为一个等价类，因此每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述 T ，从而构造 T 的时间复杂度为 `O(|E|log|E|)` 。因此，Kruskal 算法适合于边稀疏而顶点较多的图。

## 2. 最短路径

[5.3 节所述的广度优先搜索查找最短路径只是对无权图而言的](https://dengwenfeng.com/data-structure/2019/09/05/traverse-of-graph.html#12-bfs-算法求解单源最短路径问题) 。图是带权图时，把从一个顶点 v0 到图中其余任意一个顶点 vi 的一条路径（可能不止一条）所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径称为最短路径。

求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图 G 的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的 Dijkstra 算法求解；二是求每对顶点间的最短路径，可通过 Floyd-Warshall 算法来求解。

### 2.1 Dijkstra 算法求单源最短路径问题

求带权有向图中某个源点到其余各顶点的最短路径时，最常用的是 Dijkstra 算法。该算法设置一个集合 S 记录已求得的最短路径的顶点，可用一个数组 `s[]` 来实现，初始化为 0，`s[vi]=1` 时表示将顶点 vi 放入 S，初始时把源点 v0 放入 S。此外，在构造过程中还设置了两个辅助数组：

1. `dist[]` ：记录从源点 v0 到其他各顶点当前的最短路径长度，`dist[i]` 的初值为 `arcs[v0][i]` 。
2. `path[]` ：`path[i]` 表示从源点到顶点 i 之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点 v0 到顶点 vi 的最短路径。

假设从顶点 0 出发，即 v0=0 ，集合 S 最初只包含顶点 0，邻接矩阵 arcs 表示带权有向图，`arcs[i][j]` 表示有向边 `<i,j>` 的权值，若不存在有向边 `<i,j>` ，则 `arcs[i][j]` 为 ∞ 。Dijkstra 算法的步骤如下（不考虑对 `path[]` 的操作）：

1. 初始化：

### 2.2 Floyd 算法求各顶点之间最短路径问题

## 3. 拓扑排序

## 4. 关键路径

### 4.1 事件 vk 的最早发生时间 vc(k)

### 4.2 事件 vk 的最迟发生时间 vl(k)

### 4.3 活动 ai 的最早开始时间 e(i)

### 4.4 活动 ai 的最迟开始时间 l(i)

### 4.5 一个活动 ai 的最迟开始时间 l(i) 和其最早开始时间 e(i) 的差额 d(i)=l(i)-e(i)

