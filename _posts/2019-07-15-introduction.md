---
title: 1. 绪论
---

## 1. 数据结构的基本概念

### 1.1 基本概念和术语

1. 数据

   数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。

2. 数据元素

   数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据组成。

3. 数据对象

   数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是集合 

   $N=\lbrace 0, \pm 1, \pm2,\cdots \rbrace$ 

4. 数据类型

   数据类型是一个值的集合和定义在此集合上的一组操作的总称。

   1. 原子类型。其值不可再分的数据类型
   2. 结构类型。其值可以再分解为若干成分（分量）的数据类型
   3. 抽象数据类型。抽象数据组织及与之相关的操作。

5. 抽象数据类型

   抽象数据类型（ADT）是指一个数据模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。通常用（数据对象、数据关系、基本操作集）这样的三元组来表示抽象数据类型。

6. 数据结构

   在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。

### 1.2 数据结构三要素

1. 数据结构的逻辑结构

   逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。

   集合：结构中的数据元素之间除 “同属于一个集合” 的关系外，别无其他关系。

   线性结构：结构中的数据元素之间只存在一对一的关系。

   树型结构：结构中的数据元素之间存在一对多的关系。

   图状结构或网状结构：结构中的数据元素之间存在多对多的关系

   ![数据结构的逻辑结构](/data-structure/img/structure.png)

2. 数据的存储结构

   存储结构是指数据结构在计算机中的表示（又称映像），也叫物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据结构主要有顺序结构、链式结构、索引结构和散列结构。

   - 顺序结构

     把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。

   - 链式存储

     不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元；缺点是每个元素因存储指针而占用较多的存储空间，且只能实现顺序存取。

   - 索引存储

     在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式时（关键字，地址）。其优点是检索速度快；缺点是增加附加的索引表后会占用较多的存储空间。另外，在增加和删除数据时要修改索引表，因而会花费较多的时间。

   - 散列存储

     根据元素的关键字直接计算出该元素的存储地址，又称 Hash 存储。其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。

3. 数据的运算

   施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。

### 1.3 习题

1. 可以用（）来定义一个完整的数据结构？

   数据元素；数据对象；数据关系；抽象数据类型

2. （）是非线性数据结构？

   树；字符串；队列；栈

3. 以下属于逻辑结构的是（）。

   顺序表；哈希表；有序表；单链表

4. 以下与数据的存储结构无关的术语是

   循环队列；链表；哈希表；栈

5. 讲讲数据结构、逻辑结构和存储结构的关系

6. 在存储数据时，通常不仅要存储各数据元素的值，而且要存储（）。

7. 链式存储设计时，结点内的存储单元地址（）。

8. 对于两种不同的数据结构，逻辑结构或物理结构一定不相同吗？

9. 举例说明相同的逻辑结构，不同的存储结构导致其运算效率不同。

### 1.4 习题答案

1. 抽象数据类型
2. 树
3. 有序表，可以链式存储，可以顺序存储
4. 栈，因为栈可以用链表实现可以用顺序表实现。注意：循环队列是用顺序表实现的。
5. 数据结构包含逻辑结构和存储结构。逻辑结构重在数据的描述，存储结构重在数据的存储。
6. 数据元素之间的关系。
7. 一定连续（注意是结点内而不是结点间）
8. 可能相同，例如二叉树和二叉排序树，其操作集不同，但是存储结构是相同的。
9. 线性表用顺序存储实现方式的话查找快，增删慢；用链表实现的话增删快，查找慢。

## 2. 算法和算法评价

### 2.1 算法的基本概念

算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列 5 个重要特性：

1. 有穷性。一个算法（对任何合法的输入值）必须总是在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. 确定性。算法中每条指令必须有确切的含义，读者理解时不会产生二义性，即对于相同的输入只能得到相同的输出。
3. 可行性。一个算法时可行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。
4. 输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
5. 输出。一个算法有一个或多个输出，这些输出是与输入有着特定关系的量。

通常，设计一个 “好” 的算法应考虑达到以下目标

1. 正确性。算法应能够正确地解决问题。
2. 可读性。算法应具有良好的可读性，以帮助人们理解。
3. 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
4. 效率与低存储需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。

### 2.2 算法效率的度量

算法效率的度量是通过时间复杂度和空间复杂度来描述的。

1. 时间复杂度

   一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为 T(n) ，它是该算法问题规模 n 的函数，时间复杂度主要分析 T(n) 的数量级。算法中基本运算（最深层循环内的语句）的频度与 T(n) 同数量级，因此通常采用算法中基本运算的频度 f(n) 来分析算法的时间复杂度。因此，算法的时间复杂度记为

    $T(n)=O(f(n))$ 

   式中，O 的含义是 T(n) 的数量级，其严格的数学定义是：若 T(n) 和 f(n) 是定义在整数集合上的两个函数，则存在正常数 C 和 $n_0$ ，使得当 $n\ge n_0$ 时，都满足 $0\le T(n) \le Cf(n)$ 。

   算法的时间复杂度不仅依赖于问题的规模 n ，也取决于带输入数据的性质（如输入数据的初始状态）。

   例如：从 n 个数中查找一个值为 k 的数。那么这个算法的时间复杂度和是否有这个数、以及这个数的位置有关

   - 最坏复杂度

     最坏情况下，算法的时间复杂度

   - 平均复杂度

     所有可能输入实例在等概率出现的情况下，算法的期望运行时间

   - 最好时间复杂度

     最好情况下，算法的时间复杂度

   一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。

   在分析一个程序的时间复杂性时，有以下两条规则：

   1. 加法规则

      $T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$

   2. 乘法规则

      $T(n)=T_1(n)\times T_2(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$

   常见的渐近时间复杂度为

   $O(1) <O(\log_2n)<O(n)<O(n\log_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$

2. 空间复杂度

   算法的空间复杂度 S(n) 定义为该算法所消耗的存储空间，它是问题规模 n 的函数。渐近空间复杂度也常简称为空间复杂度，记为 $S(n)=O(g(n))$

   一个上机程序除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储为实现计算所需的一些信息的辅助空间，若输入数据所占空间只取决于问题本身而与算法无关，则只需分析除输入和程序外的额外空间。

   算法原地工作是指算法所需的辅助空间为常量，即 O(1) 。

### 2.3 习题

简答题

1. 一个算法应该是

   程序；问题求解步骤的描述；要满足五个基本特性

2. 某算法的时间复杂度为 $O(n^2)$ ，表明：

3. 已知两个长度分别为 m 和 n 的升序链表，若将它们合并为一个长度为 m+n 的降序链表，则最坏情况下的时间复杂度是

4. 下面说法中错误的是

   1. 算法原地工作的含义是指不需要任何额外的辅助空间
   2. 在相同规模 n 下，复杂度为 O(n) 的算法在时间上总是优于复杂度为 $O(2^n)$ 的算法
   3. 所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界
   4. 同一个算法，实现的语言的级别越高，执行效率越低

综合题

- 一个算法所需时间由下述递归方程表示，试求出该算法的时间复杂度的级别（或阶）
  $$
  T(n)=
  \begin{cases}
  1, n=1 \\
  2T(n/2) +n,n>1
  \end{cases}
  $$
  

### 2.4 习题答案

简答题

1. 问题求解步骤的描述。程序可以是死循环，例如操作系统
2. 执行时间与 $n^2$ 呈正比
3. $O(max(m,n))$ ，注意是将升序的合并为降序
4. 1 是错的。注意 2 是对的，不要拿特殊值说事

综合题

- 每次递归规模减一半，递归的次数是 $\log_2n$ ，每次递归的规模是 n，所以总共是 $n\log_2n$ 。



## 归纳总结

重点是时间复杂度。掌握分析时间复杂度的方法和步骤，要规范地表述其推导过程。一般有两种形式。

1. 循环主体中的变量参与循环条件的判断

   ```c++
   int i =1;
   while(i <= n) i= i*2
   ```

   则有 $2^t \le n$ ，取对数后得到 $t\le \log_2n$ ，故时间复杂度为 $O(\log_2n)$ 。

2. 循环主体中的变量与循环条件无关

   一般采用数学归纳法或直接累计循环次数。多重循环时从内到外分析，忽略单步语句、条件判断语句，只关注主题语句的执行次数。分递归和非递归

   - 递归程序。利用公式进行递推

     $T(n)=1+T(n-1)=1+1+T(n-2)=\cdots$

   - 非递归直接累加

例子：斐波那契数列递归和非递归的时间复杂度

解：递归：每次规模减小的同时计算次数翻倍，就像二叉树一样散开，求和得到 $O(2^n)$

非递归：前一次的计算结果可以作为后一次的输入值，时间复杂度仅为 $O(n)$



{{site.math}}