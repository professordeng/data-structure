---
title: 7.7 External Sorting
date: 2019-09-13
---

外部排序的算法比较复杂，主要内容有

1. 外部排序指待排序文件较大，内存一次放不下，需存放在外部介质的文件的排序。
2. 为减少平衡归并中外存读写次数所采取的方法：增大归并路数和减少归并段个数。
3. 利用败者树增大归并路数
4. 利用置换-选择排序增大归并段长度来减少归并段个数
5. 由长度不等的归并段，进行多路平衡归并，需要构造最佳归并树

## 1. 外部排序的基本概念

在许多实际应用中，经常需要对大文件进行排序，因为文件中的记录很多、信息量庞大，无法将整个文件复制到内存中进行排序。因此，需要将待排序的记录存储在外存上，排序时再把数据一部分地调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序方法就称为外部排序。

## 2. 外部排序的方法

在实际应用中，由于外存设备的不同，通常又可分为磁盘文件排序和磁带文件排序两大类。磁带文件排序和磁盘文件排序的基本步骤类似，主要不同之处是初始归并段在外存介质中的分布方式，磁盘是直接存取设备，磁带是顺序存取设备。下面以磁盘为例进行说明。

文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读写的。因为磁盘读/写的机械动作所需的时间远远超过内存运算的时间（相比而言可以忽略不计），因此在外存排序过程中的时间代价主要考虑访问磁盘的次数，即 I/O 次数。

外部排序通常采用归并排序算法。它包括两个相对独立的阶段：首先，根据内存缓冲区的大小，将外存上含有 n 个记录的文件分成若干长度为 h 的子文件，依次读入内存并利用有效的内部排序算法对它们进行排序，并将排序后得到的有序子序列重新写回外存，通常称这些有序子文件为归并段或顺串；然后，对这些归并段进行逐趟归并，使归并段（有序的子文件）逐渐由小到大，直至得到整个有序文件为止。

例如，一个含有 2000 个记录的文件，每个磁盘块可以容纳 250 个记录，则该文件包含 8 个磁盘块。然后对该文件做 2 路归并排序，每次向内存读入两个磁盘块，排序后再写回磁盘。若把内存工作区等分为 3 个缓冲区，其中两个为输入缓冲区，一个为输出缓冲区，则可以在内存中利用简单 2 路归并 `merge()` 函数实现 2 路归并。

首先，从参与归并排序的两个输入归并段 `R1` 和 `R2` 分别读入一个块，放在输入缓冲区 1 和输入缓冲区 2 中。然后，在内存中进行 2 路归并，归并出来的对象顺序存放在输出缓冲区中。若输出缓冲区中对象存满，则将其内的对象顺序写到输出归并段中 `R1'` 中，再将该输出缓冲区清空，继续存放归并后的对象。若某个输入缓冲区中的对象取空，则从对应的输入归并段中再读取下一块（这种情况在第一趟归并时不会出现，因为第一趟的归并段只有一块），继续参加归并。如此继续，直到两个输入归并段中的对象全部读入内存并都归并完成为止。当 `R1` 和 `R2` 归并后，再归并 `R3` 和 `R4` 、`R5` 和 `R6` 、最后归并 `R7` 和 `R8` ，这时一趟归并。再把这趟归并的结果 `R1'` 、`R2'` 、`R3'` 和 `R4'` 两两归并，这又是一趟归并。最后把 `R1”` 和 `R2“` 两个归并段归并，结果得到最终的有序文件，一共进行了 3 趟归并。

再外部排序中实现两两归并时，不仅要调用 `merge()` 过程，而且需要不停地将数据读出、写入磁盘，而这会耗费大量的时间。一般情况下 

```c++
外部排序的总时间 = 内部排序所需的时间 + 外存信息读取的时间 + 内部归并所需的时间
tES = r·tIS + d·tIO + S(n-1)tmg
```

式中，r 是初始归并段的个数，`tIS` 是对每个初始归并段进行内部排序的时间，d 是访问外存块的次数，`tIO` 是每个块的存取时间，S 是归并趟数，n 是每趟参加 2 路归并的记录个数，`tmg` 是每做一次内部归并时，取得一个关键字最小记录的时间。显然，磁盘存取的时间远大于内部排序和内部归并的时间，因此要提高外部排序的速度，应着力减少 d，即 I/O 次数。

由于外存上信息的读/写是以 ”物理块“ 为单位的，且每个物理块可容纳 250 个记录，可知每一趟归并需进行 8 次 ”读“ 和 8 次 ”写“ ，3 趟归并加上内部排序时所需进行的读/写，使得在外部排序中共需进行 16×4=64 次读写。故上述 2 路平衡归并排序的总时间为

```c++
8·tIS + 64·tIO + 3×2000·tmg
```

对于上例，若采用 4 路归并排序，则只需要 2 趟归并，外部排序时的总读/写次数便减至 2×16+16=48 。因此，增大归并路数，可减少归并趟数，进而减少总的磁盘 I/O 次数。

一般地，对 r 个初始归并段，做 m 路平衡归并，归并树可用严格 m 叉树（即只有读为 m 与度为 0 的结点的 m 叉树）来表示。第一趟可将 r 个初始归并段归并为 `r/m 上取整` 个归并段，以后每趟归并将 `x` 个归并段归并成 `x/m 上取整` 个归并段，直到最后形成一个大的归并段为止。树的高度 = `logmr上取整` = 归并趟数 S。可见，只要增大归并路数 m，或减少初始归并段个数 r，都能减少归并趟数 S，进而减少读写磁盘的次数 d，达到提高外部排序速度的目的。

## 3. 多路平衡归并与败者树

上节提到，增加归并趟数 m 可以减少归并趟数 S，进而减少访问外存的次数（I/O）次数。然而，增加归并路数 m 时，内部归并的时间将增加。做内部归并时，在 m 个元素中选择关键字最小的记录需要比较 m-1 次。每趟归并 n 个元素需要做 (n-1)(m-1) 次比较，S 趟归并总共需要的比较次数为 

```c++
S(n-1)(m-1)=logmr上取整(n-1)(m-1)=log2r上取整(n-1)(m-1)/log2m上取整
```

式中，`log2r上取整(n-1)` 在初始归并段个数 r 与记录个数 n 一定时是常数，而 `(m-1)/log2m上取整` 随 m 增大而增大，因此内部归并时间亦随 m 的增大而增大。这将抵消由于增大 m 而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并排序算法。

为了使内部归并不受 m 的增加的影响，引入了败者树。败者树是树形选择排序的一种变体，可视为一棵完全二叉树。每个叶结点存放各归并段在归并过程中当前参加比较的记录，内部结点用来记录左右子树的 ”失败者“ ，而让胜者往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。

因为 m 路归并的败者树深度为  `log2m上取整` ，因此 m 个记录中选择最小关键字，最多需要 `log2m上取整` 次比较。所以总的比较次数为 

```c++
S(n-1)·log2m上取整 = logmr上取整·(n-1)log2n上取整 = (n-1)log2r上取整
```

可见，使用败者树后，内部归并的比较次数与 m 无关了。因此，只要内存空间允许，增大归并路数 m 将有效地减少归并树的高度，从而减少 I/O 次数 d，提高外部排序的速度。

值得注意的是，归并路数 m 的选择并不是越大越好。归并路数 m 增大时，相应地需要增加输入缓冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大（一次读入要分几次读入）。当 m 值过大时，虽然归并趟数会减少，但读写外存的次数仍会增加。 

## 4. 置换-选择排序（生成初始归并段）

利用 m 路归并可以减少磁盘访问次数，减少初始归并段个数 r 也可以减少归并趟数 S 。若总的记录个数为 n，每个归并段的长度为 `l` ，则归并段的个数 `r=n/l上取整` 。若采用前面介绍的内部排序算法，将得到长度都相等的初始归并段。因此，必须探索新的算法来生成初始归并段，也就是置换-选择算法。

设初始待排文件为 `FI`，初始归并段文件为 `FO` ，内存工作区为 `WA` ，内存工作区可容纳 w 个记录。置换-选择算法的步骤如下：

1. 从待排文件 `FI` 输入 w 个记录到工作区 `WA` 。
2. 从内存工作区 `WA` 中选出其中关键字最小的记录，记为 MINIMAX（以后再选出关键字比它大的记录归入本归并段，比它小的归入下一归并段）
3. 将 MANIMAX 记录输出到 FO 中
4. 若 FI 未读完，则从 FI 输入下一个记录到 WA 中。
5. 从 WA 中所有关键字比 MINIMAX 记录的关键字大的记录中选出最小的关键字记录，作为新的 MINIMAX 。
6. 重复 3~5 ，直到在 WA 中选不出新的 MINIMAX 记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到 FO 中。
7. 重复 2~6，直到 WA 为空。由此得到全部初始归并段

上述算法中，选择 MINIMAX 记录的过程需利用败者树来实现。

## 5. 最佳归并树



