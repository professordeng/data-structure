---
title: 7.2 insert sort
date: 2019-09-12
---

插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。

由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序和希尔排序。下面将依次进行讲解。

## 1. 直接插入排序

对 `3 1 2 6 5 7` 进行升序插入排序，过程如下

1. 第一个元素默认有序，从第二个元素开始，1 比 3 小 ，将 1 插入到 3 之前，得到 `1 3` 
2. 对 `1 3` 从后往前找适合 2 的插入位置，得到 `1 2 3` 
3. 依次类推，每次插一个，直到插完。

直接插入排序算法的性能分析如下：

空间效率：仅使用了常数个辅助单元，因而空间复杂度为 `O(1)` 。

时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了 n-1 遍，每趟操作部分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。

在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为 `O(n)` 。

在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达到最大，为 `Σi` ，总的移动次数也达到最大，为 `Σ(i+1)` 

平均情况下，考虑到待排序表中的元素是随机的，此时可以取上述最好与最坏情况下的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均为 `n^2/4` 。

由此，直接插入排序算法的时间复杂度为 `O(n^2)` 。虽然折半插入排序算法的时间复杂度也为 `O(n^2)` ，但对于数据量比较小的排序表，折半插入排序往往能表现出很好的性能。

稳定性：由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序算法。

适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。注意：大部分排序算法都仅适用于顺序存储的线性表。

## 2. 折半插入排序

从前面的直接插入排序算法中，不难看出每趟插入的过程中，都进行了两项工作

1. 从前面的子表中查找出待插入元素应该被插入的位置
2. 给插入位置腾出空间，将待插入元素复制到表中的插入位置。

注意到该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序存储的线性表时，可以对直接插入排序算法做如下改进：由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。

折半插入排序仅减少了比较元素的次数，约为 `O(nlog2n)` ，该比较次数与待排序表的初始条件无关，仅取决于表中个数 n；而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为 `O(n^2)` 。折半插入排序是一种稳定的排序方法。

## 3. 希尔排序

直接插入排序算法适用于基本有序的排序表和数据量不大的排序表。基于这两点，发明了希尔排序，又称缩小增量排序。

希尔排序的基本思想是：先将待排序表分割成若干形如 `i,i+d,i+2d,...,i+kd` 的 “特殊” 子表，分别进行直接插入排序，当整个表的元素已呈 “基本有序” 时，再对全体记录进行一次直接插入排序。

希尔排序的排序过程如下：先取一个小于 n 的步长 d1，把表中的全部记录分成 d1 组，所有距离为 d1 的倍数的记录放为同一组中，在各组中进行直接插入排序；然后取第二个步长 d2<d1，重复上述过程，直到所取到的 `dt=1` ，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终效果。到目前为止，尚未求得一个最好的增量序列，希尔提出的方法是 d1=n/2 ，d(i+1)=di/2下取整 。并且最后一个增量等于 1 。

希尔排序算法的性能分析如下：

空间效率：仅使用了常数个辅助单元，因而空间复杂度为 `O(1)` 。

时间效率：由于希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当 n 在某个特定范围时，希尔排序的时间复杂度约为 `O(n^1.3)` 。在最坏情况下希尔排序的时间复杂度为 `O(n^2)` 。

稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序算法。例如，表 `3,2,2` 经过一趟排序后，2 的相对位置就发生了改变。