---
title: 7.4 select sort
date: 2019-09-12
---

选择排序的基本思想是：每一趟（如第 `i` 趟）在后面 `n-i+1(i=1,2,,..,n-1)` 个待排序元素中选取关键字最小 的元素，作为有序子序列的第 `i` 个元素，直到第 `n-1` 趟排完，待排序元素只剩下 1 个，就不用再选了。

## 1. 简单选择排序

根据上面选择排序是思想，可以很直观地得出简单选择排序算法的思想：假设排序表为 `L[1~n]` ，第 `i` 趟排序即从 `L[i~n]` 中选择关键字最小的元素与 `L(i)` 交换，每一趟排序可以确定一个元素的最终位置，这样经过 n-1 趟排序就可使得整个排序表有序。

简单选择排序算法的性能分析如下：

空间效率：仅使用常数个辅助单元，故空间效率为 `O(1)`

时间效率：在简单选择排序中，元素移动的操作次数很小，不会超过 `3(n-1)` 次，最好的情况是移动 0 次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是 `n(n-1)/2` 次，所以时间复杂度始终为 `O(n^2)` 。

稳定性：在第 `i` 趟找到最小元素后，和第 `i` 个元素交换，可能导致第 `i` 个元素于其含有相同关键字元素的相对位置发生改变。例如 `1 2 2` 。因此，简单选择排序是一种不稳定的排序算法。

## 2. 堆排序

堆排序是一种树形选择排序方法，其特点是：在排序过程中，将 `L[1~n]` 视为一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序区中选择关键字最大（或最小）的元素。

堆的定义如下：n 个关键字序列 `L[1~n]` 称为堆，当且仅当该序列满足：

1. `L(i)≤L(2i)` 且 `L(i)≤L(2i+1)` ，或
2. `L(i)≥L(2i)` 且 `L(i)≥L(2i+1)`

满足第 1 种情况的堆称为小根堆（小顶堆），满足第 2 种情况的堆称为大根堆（大顶堆）。显然，在大根堆中，最大元素存放在根结点中，且对任一非根结点，它的值小于等于其双亲结点值。小根堆的定义刚好相反，根结点是最小元素。堆经常被用来实现优先级队列，优先级队列在操作系统的作业调度和其他领域有广泛的应用。

堆排序的关键是构造初始堆，堆初始序列建堆，是一个反复筛选的过程。n 个结点的完全二叉树，最后一个结点是第 `n/2下取整` 个结点的孩子。对第 `n/2下取整` 个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对各结点（`n/2下取整-1~1`）为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。

向下调整的时间与树高有关，为 `O(h)` 。建堆过程中每次向下调整时，大部分结点的高度都较小。因此，可以证明在元素个数为 n 的序列上建堆，其时间复杂度为 `O(n)` ，这说明可以在线性时间内将一个无序数组建成一个大顶堆。

应用堆这种数据结构进行排序的思路很简单：首先将存放在 `L[1~n]` 中的 n 个元素建成初始堆，由于堆本身的特点（以大顶堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆低元素送上堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩下一个元素为止。

同时，堆也支持删除和插入操作。由于堆顶元素或为最大值或为最小值，删除堆顶元素时，先将堆的最后一个元素与堆顶元素交换，由于此时堆的性质被破坏，需对此时的根结点进行向下调整操作。对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点执行向上调整操作。

堆排序算法的性能分析如下：

空间效率：仅使用了常数个辅助单元，所以空间复杂度为 `O(1)` 。

时间效率：建堆时间为 `O(n)` ，之后有 n-1 次向下调整操作，每次调整的时间复杂度为 `O(h)` ，故在最好、最坏和平均情况下，堆排序的时间复杂度为 `O(nlog2n)` 。

稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面来，所以堆排序算法是一种不稳定的排序算法。例如 `1 2 2` ，建堆时，第二个 2 成为根结点，随后被放到最后。 