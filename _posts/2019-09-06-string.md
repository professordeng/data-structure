---
title: 6.5 string
date: 2019-09-11
---

字符串简称串，计算机上非数值处理的对象基本都是字符串数据。我们常见的信息检索系统（如搜索引擎）、文本编辑次序（如 word）、问答系统、自然语言翻译系统等，都是以字符串数据作为处理对象的。本章详细介绍字符串的存储结构及相应的操作。

## 1. 串的定义

串（string）是由零个或多个字符组成的有限序列。一般记为

```c++
S = 'a1a2...an' (n≥0)
```

其中，S 是串名，单引号括起来的字符序列是串的值；ai 可以是字母、数字或其他字符；串中字符的个数 n 称为串的长度。n=0 时的串称为空串。

串中任意个连续的字符组成的子序列称为该串的子串，包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置以子串的第一个字符在主串中的位置来表示。当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的 。

需要注意的是，由一个或多个空格（空格是特殊字符）组成的串称为空格串（注意，空格串不是空串），其长度为串中空格字符的个数。

串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。在基本操作上，串和线性表有很大差别。线性表的基本操作主要以单个元素作为操作对象，如查找、插入或删除某个元素等；而串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。

## 2. 串的存储结构

### 2.1 定长顺序存储表示

类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，为每个串编码分配一个固定长度的存储区，即定长数组。

```c++
#define MAXLEN 255  // 预定义最大串为 255

struct SString {
    char ch[MAXLEN];  // 每个分量存储一个字符
    int length;       // 串的实际长度
};
```

串的实际长度只能小于等于 MAXLEN ，超过预定义长度的串值会被舍去，称为截断 。串长有两种表示方法；一是如上述定义描述的那样，用一个额外的变量 length 来存放串的长度；二是在串值后面加一个不计串长的结束标记字符 `\0` ，此时的串长为隐含值。

在一些串的操作（如插入、连接等）中，若串值序列的长度超过上界 MAXLEN ，约定用 “截断” 法处理，要克服这种弊端，只能不限定串长的最大长度，即采用动态分配的方式。

### 2.2 堆分配存储表示

堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。

```c++
struct HString {
    char *ch;     // 按串长分配存储区
    int lenght;   // 串的长度
};
```

在 C++ 语言中，存在一个称之为 “堆” 的自由存储区，并用 new 和 delete 操作符来完成动态存储管理 。利用 new 为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基地址，这个串由 ch 指针来表示；若分配失败，则返回 NULL 。已分配的空间可用 delete 释放掉 。

上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。

### 2.3 块链存储表示

类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只有一个字符），在具体实现时，每个结点既可用存放一个字符，又可以存放多个字符。每个结点称为块，整个链表称为块链结构。

## 3. 串的基本操作

- `StrAssign(&T,chars)` ：赋值操作。吧串 T 赋值为 chars 。
- `StrCopy(&T,S)` ：复制操作 。由串 S 复制得到串 T 。
- `StrEmpty(S)` ：判空操作 。若 S 为空串，则返回 TRUE ，否则返回 FALSE 。
- `StrCompare(S,T)` ：比较操作 。若 S>T，则返回值 >0 ；若 S=T，则返回值 =0，若 S <T，则返回值 < 0 。
- `StrLength(S)` ：求串长。返回串 S 的元素个数。
- `SubString(&Sub, S, pos, len)` ：求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。
- `Concat(&T, S1, S2)` ：串联接 。用 T 返回由 S1 和 S2 联接而成的新串 。
- `Index(S, T, pos)` ：定位操作 。若主串 S 中存在与串 T 值相同的子串 ，则返回它在主串 S 中第 pos 个字符之后第一次出现的位置；否则函数值为 0 。
- `Replace(&S, T, V)` ：替换子串 。用 V 替换主串 S 中出现的所有与 T 相等的不重叠的子串 。
- `StrInsert(&S, pos, T)` ：在串 S 的第 pos 个字符之前插入串 T 。
- `StrDelete(&S, pos, len)` ：删除子串 。从串 S 中删除第 pos 个字符起长度为 len 的子串。
- `ClearString(&S)` ：清空操作 。将 S 清为空串 。
- `DestroyString(&S)` ：销毁串 。将串 S 销毁 。

对于串的基本操作集，不同的高级程序设计语言可以有不同的定义方法。在上述定义的操作中，串赋值 `StrAssign` 、串比较 `StrCompare` 、求串长 `StrLength` 、串联接 `Concat` 及求子串 `SubString` 五种操作构成串类似的最小操作子集 ，即这些操作不可能利用其他串操作来实现；反之，其他串操作（除串清除 `ClearString` 和串销毁 `DestroyString` 外）均可在这个最小操作子集上实现 。

## 4. 串的模式匹配

子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串的位置。上节中曾利用串的其他基本操作给出了定位操作的一种算法，这里采用定长顺序存储结构，写出一种不依赖于其他串操作的匹配算法。

```c++
int Index() ... 未完待续
```

在上述算法中，分别用计数指针 i 和 j 指示主串 S 和模式串 T 中当前正待比较的字符位置。算法思想为：从主串 S 的第 pos 个字符起，与模式的第一个字符比较，若相等，则继续逐个比较后序字符；否则从主串的下一个字符起，重新和模式的字符比较；以此类推，直至模式 T 中的每个字符依次和主串 S 中的一个连续的字符序列相等，则称匹配成功，函数值为与模式 T 中第一个字符相等的字符在主串 S 中的序号，否则称匹配不成功，函数值为零。

简单模式匹配算法的最坏时间复杂度为 `O(nm)` ，其中 n 和 m 分别为主串和模式串的长度。 

## 5. 改进的模式匹配算法（KMP 算法）

KMP 算法利用比较过的信息，i 指针不需要回溯，仅将子串向后滑动一个合适的位置，并从这个位置开始和主串进行比较，这个合适的位置仅与子串本身的结构有关，而与主串无关。

### 5.1 字符串的前缀、后缀和部分匹配值



### 5.2 KMP 算法的原理

