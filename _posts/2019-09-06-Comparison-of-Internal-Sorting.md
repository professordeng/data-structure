---
title: 7.6 Comparison of Internal Sorting
date: 2019-09-12
---

## 1. 内部排序算法的比较

本系列提到的排序算法很多，一般基于三个因素进行对比：时空复杂度、算法的稳定性、算法的过程特征。

从时间复杂度来看，简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为 `O(n^2)` ，且实现过程也较简单，但直接插入排序和冒泡排序最好情况下的时间复杂度也可以达到 `O(n)` ，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但目前未得到其精确的渐近时间。堆排序利用了一种称为堆的数据结构，可在线性时间内完成建堆，且在 `O(nlog2n)` 完成排序过程。快速排序基于分治的思想，虽然最坏情况下快速排序时间会达到 `O(n^2)` ，但快速排序平均性能可以达到 `O(nlog2n)` ，在实际应用中常常优于其他排序算法。归并排序同样基于分治的思想，但由于其分割子序列与初始序列的排列无关，因此它的最好、最坏和平均时间复杂度均为 `O(nlog2n)` 。

从空间复杂度来看，简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需要借助常数个辅助空间。快速排序在空间上只需要一个小的辅助栈，用于实现递归，平均情况下大小为 `O(log2n)` ，当然在最坏情况下可能增长到 `O(n)` 。2 路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为 `O(n)` ，虽然有方法克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。

从稳定性看，插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序算法。对于排序方法的稳定性，应从算法本身的原理上理解，切勿死记硬背。

从过程特征看，采用不同的排序算法，在一次循环或几次循环后的排序结构可能是不同的。给出一个待排序的初始序列和已经部分排序的序列，有时可以看出采用何种算法。这需要堆各类排序算法的过程特征十分熟悉，如冒泡排序和堆排序在每次循环后都能产生当前的最大值或最小值，而快速排序一次循环就能确定一个元素的最终位置等。

下列给出各种排序算法的时间复杂度、空间复杂度和稳定性情况，其中空间复杂度仅列举了平均情况下的复杂度，由于希尔排序的时间复杂度的时间复杂度依赖于增量函数，所以这里无法准确地给出其时间复杂度。（O() 就不写了）

| 算法     | 最好时间 | 平均时间 | 最坏时间 | 平均空间 | 是否稳定 |
| -------- | -------- | -------- | -------- | -------- | -------- |
| 直接插入 | n        | n^2      | n^2      | 1        | 是       |
| 冒泡排序 | n        | n^2      | n^2      | 1        | 是       |
| 简单选择 | n^2      | n^2      | n^2      | 1        | 否       |
| 希尔排序 |          |          |          | 1        | 否       |
| 快速排序 | nlog2n   | nlog2n   | n^2      | log2n    | 否       |
| 推排序   | nlog2n   | nlog2n   | nlog2n   | 1        | 否       |
| 二路归并 | nlog2n   | nlog2n   | nlog2n   | n        | 是       |
| 基数排序 | d(n+r)   | d(n+r)   | d(n+r)   | r        | 是       |

## 2. 内部排序算法的应用

通常情况下，对排序算法的比较和应用应考虑以下情况：

1. 选取排序方法需要考虑的因素
   1. 待排序的元素数目 n
   2. 元素本身信息量的大小
   3. 关键字的结构及其分布情况
   4. 稳定性的要求
   5. 语言工具的条件，存储结构及辅助空间的大小等。
2. 排序算法小结
   1. 若 n 较小（n≤50），则可采用直接插入排序或简单选择排序。由于直接插入排序时所需的记录移动操作较简单选择排序的多，因而当记录本身信息量较大时，用简单选择排序较好。
   2. 若文件的初始状态已按关键字基本有序时，则选中直接插入或冒泡排序为宜。
   3. 若 n 较大，则应采用时间复杂度为 `O(nlog2n)` 的排序方法：快速排序、堆排序或归并排序。快速排序被认为是目前基于比较的内部排序法中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间最短。堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。若要求排序稳定且时间复杂度为 `O(nlog2n)` ，则可选用归并排序。但从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子序列，然后两两归并。直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。
   4. 在基于比较的排序方法中，每次比较两个关键字的大小后，仅出现两种可能的转换，因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的 n 个关键字随机分布时，任何借助 “比较的排序算法”，至少需要 `O(nlog2n)` 的时间。
   5. 若 n 很大，记录的关键字位数较少且可以分解时，采用基数排序较好。
   6. 当记录本身信息量很大时，为避免耗费大量时间移动记录，可用链表作为存储结构。